# InstrumentRs design decisions `v0.1.0`

This is the first release of InstrumentRs and it should be regarded as highly experimental.
I am currently trying out various designs and this is the first one I settled on 
that I think has some promise.

## What is currently supported?

- An overall `instrumentrs` crate that mainly serves:
  - An `InstrumentInterface` trait that can communicates with a given instrument.
    Here, we use the generic variable `T` as an interface that implements this trait.
  - Standard implementation for this trait for any connection that implements `std::io::Read` and `std::io::Write`.
  - Simplified serial implementation with port and baud using `serialport`.
  - Simplified TCP/IP implementation with just IP and port using `std::net::TcpStream`.
  - Each instrument interface has a default timeout of 3 seconds, independent of the individual interface.
    This timeout can be set / queried for the interface and is implemented at the single byte reader level.
  - All reading/writing errors are forwarded as `InstrumentErrors` in order to provide
    a unified error response routine throughout InstrumentRs.
- An instrument driver for the Pfeiffer TPG36x vacuum gauge
- An instrument driver for the [DigOutBox](https://digoutbox.readthedocs.io/latest/)
- Template: A `cargo-generate` template is important in order to quickly start a new driver project.
  This template should basically write most of the boilerplate code
  and enables a quick start for a new project.


### Why are these instruments supported?

I am currently in need of a rust driver for the TPG36x vacuum gauge controller.
As one is standing nearby that I can use to test, this seemed to be a useful instrument to start with.

The DigOutBox itself is a project that I created,
thus I have a box standing in my office basically at all times.
It is also one of the most simple instrument interfaces that one can imagine, 
thus it is ideal for rapid prototyping of some new ideas.

## Design

### Origin

This first version of InstrumentRs and the driver design is heavily inspired by 
[instrumentkit](https://github.com/instrumentkit/InstrumentKit).
The reason to build something similar in Rust has nothing to do with limitations of instrumentkit,
but rather with limitations of python.

### Instrument structure

Each instrument should be structured into an instrument struct,
which holds at least an `Arc<Mutex<T>>` to the interface `T`.
Furthermore, if the instrument has more than one channel, 
a channel struct should be provided that holds:

- A reference to the channel number (zero-indexed).
- The interface itself as a clone of the `Arc<Mutex<T>>` from the instrument struct.

Additionally, units for the channel measurements should be included as well (see however potential problem below).

### Why these choices

- Channel separate from the instrument: This does require re-implementing the communication 
  for a channel and for the instrument separately. 
  However, from my experience with instrumentkit, this is in fact really convenient.
- Why the `Arc<Mutex<T>>`: In order to have channels that are individually callable from the instrument,
  the interface needs to be wrapped in some structure that allows shared-access. 
  Using `Arc` further allows us to easily share this structure across various threads, 
  see, e.g., the `threading-std` example. 
  This is for example great if we want to create a UI that can send commands to individual channels 
  when the user, e.g., presses a button.
  For the UI we might however also want to have a background task 
  that reads the current status of the instrument at regular intervals. 
  This can, with the current design, be achieved by using multiple threads.

## Potential problems

- The units are currently fixed to one specific unit. 
  However, I could imagine that an instrument could have multiple functionalities on the same channel.
  For example, a multimeter can generally measure a voltage and a resistance on the same channel.
  This would currently not be expressible by the standard structure.

## Future Enhancements

These future enhancements are in order from most to least clarity in my current head.

- **Currently `std` is required**, which is not idea in case we want to support embedded developpment. 
  It would be great if all instrument drivers can work in a `std` and a `no_std` environment.
  As the target audience is mostly scientific instruments and homespun lab implementations,
  having these drivers available, e.g., from the serial interface of an
  [RPi 2350](https://www.raspberrypi.com/documentation/microcontrollers/silicon.html#rp2350) 
  would be great. 
- **Book**: In the long run, it would be very valuable to have short book available on 
  how to develop/write a new instrument driver with InstrumentRs.
- **Async support**: Currently, the library contains only blocking interfaces.
  Async support would be desirable, however, if at all possible it would be great 
  to only have to write one single driver per instrument. 
  How to do this is pretty unclear in my mind at this point.
- **Marco usage**: Macros might enhance the driver development experience. 
  The big idol here is surely [`device-driver`](https://github.com/diondokter/device-driver). 
  This goal / enhancement idea is currently far out and probably still 
  behind the visible horizon.
